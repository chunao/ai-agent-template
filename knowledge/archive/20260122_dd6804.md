---
title: FastAPIの作者が作った「SQLModel」が革命的すぎるので、全Python使いに教えたい
url: https://zenn.dev/livetoon/articles/9923c448c2734c
captured_at: 2026-01-22
published_at: 2025-12-11
---

# FastAPIの作者が作った「SQLModel」が革命的すぎるので、全Python使いに教えたい

## TL;DR & Key Conclusions
SQLModelは、PydanticとSQLAlchemyを統合したPython ORMライブラリで、FastAPIの作者が開発。DBモデルとAPIスキーマの二重管理を解消し、開発効率を大幅に向上させる。

- **二重管理の解消**: DBモデル定義とPydanticスキーマ定義を1つのクラスで統一。DRY原則に準拠し、メンテナンス性が向上
- **型安全性の向上**: SQLAlchemyの柔軟性とPydanticのバリデーション機能を両立。エディタ補完が効き、開発速度が向上
- **FastAPIとのシームレス統合**: DBモデルをそのままresponse_modelとして使用可能。Swagger UIドキュメントも自動生成
- **SQLAlchemy互換**: SQLAlchemyのラッパーとして動作するため、既存知識がそのまま活用可能。移行コストが低い
- **直感的なCRUD操作**: 従来のSQLAlchemyの「長い呪文」が不要。Pydanticライクなシンプルな記述でDB操作が可能
- **リレーション管理の簡素化**: 親子関係を持つデータを同時に保存する処理が、リストへの追加だけで実現可能
- **公式ドキュメントも移行済み**: FastAPI公式ドキュメントのSQL関連セクションが既にSQLModelベースに書き換え済み
- **モダンPython対応**: 非同期（async/await）をネイティブサポート。現代的なPython開発スタイルに適合

## Quickstart
1. **インストール**: `pip install sqlmodel aiosqlite` で必要なパッケージをインストール（非同期対応のためaiosqliteも含める）
2. **モデル定義**: `SQLModel`を継承し、`table=True`パラメータを指定してDBテーブル兼Pydanticモデルとしてクラスを定義
3. **DB初期化**: `create_async_engine`でエンジンを作成し、`SQLModel.metadata.create_all()`でテーブルを生成
4. **CRUD操作実装**: `AsyncSession`を使用して非同期的にデータベース操作を実行。インスタンス化、add、commit、refreshの流れ
5. **FastAPI統合**: DBモデルを`response_model`として直接指定し、依存性注入（SessionDep）を活用してエンドポイントを実装

## Context & Claims (Claim-Evidence-Caveat)
- **Claim**: SQLModelはDBモデルとPydanticスキーマの二重管理を解消する
    - **Evidence**: 従来はSQLAlchemyのモデルとPydanticのスキーマを別々に定義する必要があったが、SQLModelでは1つのクラス定義で両方の役割を果たせる。`table=True`で切り替え可能
    - **Caveat**: 極めて複雑なクエリが必要な場合は、SQLAlchemy生書きを選択する方が適切なケースもある
- **Claim**: FastAPIとの親和性が高く、開発効率が大幅に向上する
    - **Evidence**: DBモデルを`response_model`として直接使用でき、Swagger UIドキュメントも自動生成される。FastAPI公式ドキュメントのSQLセクションもSQLModelベースに移行済み
    - **Caveat**: FastAPI以外のフレームワークでは恩恵が限定的になる可能性がある
- **Claim**: SQLAlchemyの知識がそのまま活用できるため移行コストが低い
    - **Evidence**: SQLModelはSQLAlchemyのラッパーとして設計されており、内部的にSQLAlchemyを使用。既存のSQLAlchemy知識や経験がそのまま適用可能
    - **Caveat**: SQLAlchemy 2.0系との互換性に関する制約がある可能性（記事では明示的に言及なし）
- **Claim**: リレーションを持つデータの同時保存が簡単
    - **Evidence**: 親モデルのインスタンス作成時に子モデルをリストで渡すだけで、両方のテーブルに自動的にINSERTが実行される
    - **Caveat**: 複雑なトランザクション制御が必要な場合は別途考慮が必要
- **Claim**: 型安全性とエディタ補完により開発体験が向上する
    - **Evidence**: Pydanticの型チェック機能がそのまま使え、エディタの補完が効く。バリデーションエラーは実行時に自動検出
    - **Caveat**: 型ヒントの記述が必須となるため、初学者には学習コストが発生する可能性

## Code Snippets
- **基本的なモデル定義（ChatSessionとMessage）**: LLMチャットアプリを想定した親子関係を持つテーブル定義の例。PydanticライクなシンタックスでDBモデルを定義し、Relationshipで1対多の関係を表現
- **DB接続と初期化**: 非同期エンジンの作成とテーブル初期化の標準的な手順。SQLiteの非同期接続設定例
- **Create操作**: セッションの新規作成例。Pydanticモデルのインスタンス化、add、commit、refreshの流れ
- **Read操作**: selectクエリを使用したデータ取得の例。モダンで読みやすいクエリ構文
- **親子データの同時作成**: セッション作成時に初期メッセージも同時に保存する上級者向けパターン。messagesリストに子モデルを追加するだけで両テーブルにINSERT
- **FastAPI統合例**: SessionDepパターンを使用した依存性注入とレスポンスモデルの設定例。DBモデルを直接response_modelとして使用

## Normalized Conditions
- **Use Cases**:
    - FastAPIを使用したWeb APIの開発
    - LLMチャットアプリなどリレーションを持つデータモデルが必要な場合
    - DBモデルとAPIスキーマの二重管理によるメンテナンスコストを削減したい場合
    - 型安全性とバリデーション機能を重視する開発
    - 非同期処理を活用したモダンなPythonアプリケーション開発
    - シンプルから中程度の複雑さのDBスキーマを持つアプリケーション
- **Anti-Cases**:
    - 極めて複雑なSQLクエリが頻繁に必要な場合（SQLAlchemy生書きの方が適切）
    - FastAPI以外のフレームワークとの統合がメインの場合
    - 既存の大規模SQLAlchemyプロジェクトで移行コストが高い場合
    - プロトタイピングで型安全性よりも速度を優先する場合
- **Prerequisites**:
    - Python 3.10以上（型ヒントの`|`記法を使用）
    - Pydanticの基本的な理解
    - SQLAlchemyの基礎知識（あれば移行がスムーズ）
    - 非同期プログラミング（async/await）の理解
    - FastAPIの基本的な使用経験（統合機能を活用する場合）
- **Decision Triggers**:
    - FastAPIでRDBMSを使用したAPI開発を開始する時
    - SQLAlchemy + Pydanticの二重管理にメンテナンス負荷を感じた時
    - 新規プロジェクトでモダンなPython開発環境を構築する時
    - 型安全性とバリデーションを強化したい既存プロジェクトのリファクタリング時
    - チーム開発でコードの可読性と保守性を向上させたい時
