---
title: 「LSP」によるAI Agentのトークン削減とコード理解精度向上
url: https://zenn.dev/acntechjp/articles/18244ed3630bb1
captured_at: 2026-01-22
published_at: 2025-01-15
---

# 「LSP」によるAI Agentのトークン削減とコード理解精度向上

## TL;DR & Key Conclusions
LSP（Language Server Protocol）は、エディタと言語解析ツール間の標準化通信プロトコルであり、AI Agentがコード構造を正確に理解するための重要な技術。Claude Code、Cursor、VS Code Agent modeなどが採用している。

- **トークン削減効果**: LSPにより、ファイル全体を読み込む必要がなくなり、必要な情報だけをピンポイントで取得できるため、トークン消費が大幅に削減される
- **正確な参照解決**: テキスト検索ではなくセマンティックな解析により、import文を辿って正しいファイルを特定し、変数のスコープを正しく理解できる
- **コンテキスト理解の深化**: 型情報、関数シグネチャ、ドキュメント、クラスの継承関係などを正確に取得可能
- **リファクタリング支援**: Rename機能による全参照箇所の自動更新や、安全な変更の提案が可能になる
- **JSON-RPC 2.0を使用**: シンプルな標準入出力またはTCP/IPソケットを使った通信で実現され、複雑なプロトコルではない
- **MCPとの関係**: Anthropicが発表したMCP（Model Context Protocol）は、LSPの設計思想に強く影響を受けており、「LLMにとってのLSP」と表現される
- **多言語サポート**: Claude Codeは11言語（Python、TypeScript、Rust、Go、Java、C++など）でLSPをサポート
- **開発体験の変化**: AIが複雑な依存関係を瞬時に理解し、コンテキストを完全に把握した上で修正案を提示できるようになる

## Quickstart
Claude CodeでLSPを有効にする手順：

1. **プラグイン画面を開く**: Claude Codeで `/plugin` コマンドを実行し、「Discover」タブを開く
2. **LSPプラグインを検索**: 検索ボックスに「lsp」と入力し、使用する言語のプラグインを選択（例: `pyright-lsp`、`vtsls-lsp`、`rust-analyzer-lsp`など）
3. **インストール**: Spaceキーで選択し、`i`キーでインストール
4. **Language Serverのインストール**: プラグインとは別に、各言語のLanguage Serverバイナリ（`pyright`、`rust-analyzer`など）をシステムにインストールする必要がある
   ```bash
   # Pythonの場合
   pip install pyright
   # Rustの場合
   rustup component add rust-analyzer
   ```
5. **動作確認**: 「Installed」タブで確認し、LSP機能（定義へジャンプ、参照検索など）が使用可能になる

## Context & Claims (Claim-Evidence-Caveat)

- **Claim**: LSP登場前は、各エディタと各言語の組み合わせごとに専用プラグインが必要だった
    - **Evidence**: 言語が10種類、エディタが5種類あれば、理論上は50個のプラグインが必要になっていた
    - **Caveat**: LSPは2016年にMicrosoft、Red Hat、Codenvyによって共同開発された成熟したプロトコルである

- **Claim**: 従来のAI Agentはコードを「テキスト」として処理するため、構造や依存関係を正確に理解できなかった
    - **Evidence**: 同じ名前の別の関数を見つけてしまう、import文を辿れない、型情報や引数の詳細が不正確といった問題があった
    - **Caveat**: テキスト検索ではファイル全体を読み込む必要があり、トークン消費が大きくなる

- **Claim**: LSPを使用することで、AI AgentはエディタのようにコードのSemanticな構造を理解できるようになる
    - **Evidence**: Claude Codeでは「AuthServiceクラスの定義を教えて」というリクエストに対し、「auth/services.pyの42行目で定義されています」と正確な位置とコンテキストを返せるようになった
    - **Caveat**: 2025年1月時点ではLSPサポートはまだ実験的な段階で、プラグイン経由での起動が必要だったり、一部の言語で動作が不安定だったりする場合がある

- **Claim**: LSPの通信はHTTP/2のような複雑なプロトコルではなく、シンプルな構造である
    - **Evidence**: 標準入出力（stdin/stdout）またはTCP/IPソケットを使い、メッセージフォーマットはJSON-RPC 2.0を採用している
    - **Caveat**: Content-Lengthヘッダーで長さを指定し、本文にJSONメッセージを載せるだけのシンプルな設計

- **Claim**: MCPはLSPの設計思想に強く影響を受けている
    - **Evidence**: VS Code公式ブログでは「LSPの背後にあるアイデアが、新しいプロトコルであるMCPにインスピレーションを与えた」と述べられている
    - **Caveat**: LSPがコードの理解に特化しているのに対し、MCPはより広範な外部連携（ドキュメント、ログなど）をカバーする

- **Claim**: LSPとMCPの組み合わせにより、開発体験が大きく変化する
    - **Evidence**: 従来は「エラー→ブラウザで検索→Stack Overflow→修正→テスト」という流れだったのが、「エラー→AIに質問（LSPとMCPで解析）→修正案提示→自動適用」という流れになる
    - **Caveat**: 特に大規模なコードベースでは、AIが複雑な依存関係を瞬時に理解できることの効果が大きい

## Code Snippets
- **LSP通信の基本構造**: Content-Lengthヘッダーで長さを指定し、本文にJSON-RPC 2.0メッセージを載せる形式
- **定義ジャンプリクエスト例**: `textDocument/definition`メソッドを使用し、ファイルURIと行・列位置をパラメータとして送信する
- **定義ジャンプレスポンス例**: 定義の位置を示すファイルURIと範囲（start/endの行・列）を返す

## Normalized Conditions

- **Use Cases**:
    - AI Agentにコード構造を正確に理解させたい場合
    - 大規模なコードベースで複雑な依存関係を扱う場合
    - トークン消費を削減し、効率的なコード解析を行いたい場合
    - リファクタリングや変数名の一括変更を安全に実行したい場合
    - Claude Code、Cursor、VS Code Agent modeなどのツールを使用する場合

- **Anti-Cases**:
    - LSPサポートがまだ実験的段階であることを懸念する場合（正式サポートを待つ選択肢もある）
    - 単純な小規模プロジェクトで、コード構造の理解が不要な場合
    - 単発のテキスト解析のみで十分な場合

- **Prerequisites**:
    - Claude Code、Cursor、VS Code Agent modeなどのLSP対応ツール
    - 使用する言語のLSPプラグイン（例: `pyright-lsp`、`vtsls-lsp`など）
    - 各言語のLanguage Serverバイナリ（例: `pyright`、`rust-analyzer`など）
    - JSON-RPC 2.0に関する基本理解（深い知識は不要）

- **Decision Triggers**:
    - AI Agentがコードの参照解決で誤った候補を返すことが多い場合
    - トークン消費が大きく、コスト削減が必要な場合
    - 大規模プロジェクトでAI Agentの精度向上が求められる場合
    - リファクタリングや変更影響範囲の把握が頻繁に必要な場合
    - VS Code、Neovim、Emacsなど既存のエディタでLSPの恩恵を受けている場合
