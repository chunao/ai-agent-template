---
title: サーバーの無いReactフレームワークFUNSTACK Static
url: https://zenn.dev/uhyo/articles/funstack-static-first-release
captured_at: 2026-01-25
published_at: 2026-01-19
---

# サーバーの無いReactフレームワークFUNSTACK Static

## TL;DR & Key Conclusions
FUNSTACK Staticは、React Server Components（RSC）を活用しながら静的ファイルサーバーにデプロイできるサーバーレスReactフレームワークです。従来のSPA開発体験を維持しつつ、ビルド時処理の利便性とパフォーマンス最適化を両立します。

- **サーバーレス最優先設計**: 既存フレームワークと異なり、最初からサーバー不要を前提に設計されています
- **RSC活用によるバンドルサイズ削減**: サーバーコンポーネントのコードはクライアントバンドルに含まれず、レンダリング結果のみ送信されます
- **defer() APIによる遅延読み込み**: サーバーコンポーネント版lazy()として、必要な時点でRSCペイロードを取得します
- **Viteベース**: 専用CLIは不要で、`vite dev`/`vite build`で従来のSPA開発と同じ体験を提供します
- **ビルド時処理の柔軟性**: fsモジュールやJSONインポートがアプリケーションコード内で直接使用可能です
- **静的ファイルとして配信**: RSCペイロードがテキストファイルとして出力され、静的ホスティングで運用できます
- **制限事項あり**: ルーター機能は未提供、Server Actionsは未対応、サーバー必須のRSC機能は利用不可です
- **マイグレーション難**: 将来的にサーバー必要時のマイグレーションは容易ではありません

## Quickstart
1. **Vite設定ファイルにプラグイン追加**: `@funstack/static`をViteプラグインとして導入し、`root`（静的HTML）と`app`（SPAエントリー）の2つのエントリーポイントを指定します
2. **Rootコンポーネント作成**: HTMLドキュメント全体を表す静的コンポーネント（クライアントコンポーネント使用不可）
3. **Appコンポーネント作成**: SPA本体のサーバーコンポーネント（下層でクライアントコンポーネント使用可能）
4. **defer() APIで遅延読み込み設定**: ルーティングなどで必要に応じてページコンポーネントをdefer()でラップし、Suspenseで囲む
5. **ビルド実行**: `vite build`でRSCペイロードを含む静的ファイル群を生成
6. **静的ホスティングにデプロイ**: 生成されたファイルを任意の静的ファイルサーバーに配置

## Context & Claims (Claim-Evidence-Caveat)
- **Claim**: FUNSTACK Staticはサーバーレスを最優先に設計されている
    - **Evidence**: 著者は「既存フレームワークはサーバー運用を主流とし、静的ホスティングをおまけとして扱う傾向がある」と指摘し、対照的にFUNSTACK Staticは「最初からサーバーを立てないことを前提」に設計されていると説明
    - **Caveat**: ルーター機能やServer Actionsなど、サーバー必須の機能は提供されません。将来的にサーバーが必要になった場合のマイグレーションは容易ではありません

- **Claim**: RSC活用によりバンドルサイズとCPU負荷が削減される
    - **Evidence**: 「サーバーコンポーネントのソースコードはクライアントバンドルに含まれず、レンダリング結果のみ送信される」ため、バンドルサイズ削減とCPU負荷軽減が実現すると説明
    - **Caveat**: サーバーが必要なRSC機能（動的データ取得など）は利用できません

- **Claim**: Viteベースで従来のSPA開発と一致した体験を提供する
    - **Evidence**: 「専用CLIは不要で、`vite dev`や`vite build`コマンドで従来のSPA開発と一致した体験が得られます」と明記
    - **Caveat**: Viteプラグインとしての設定が必要で、設定ファイルに`root`と`app`の2つのエントリーポイントを指定する必要があります

- **Claim**: defer() APIにより必要な時点でのみRSCペイロードを取得できる
    - **Evidence**: 「RSCペイロードを個別に分割し、ルーティングなどで実際に必要になった時点でのみネットワークから取得します」と説明され、コード例が提示されています
    - **Caveat**: Suspenseでのラッピングが必須です

- **Claim**: ビルド時処理がアプリケーションコード内で自然に記述できる
    - **Evidence**: 「設定ファイルやデータをJavaScriptアプリケーションコード内で自然に処理でき、`fs`モジュールやJSONインポートが可能です」と説明
    - **Caveat**: これらはサーバーコンポーネント内でのみ使用可能で、クライアントコンポーネントでは使用できません

- **Claim**: RSCペイロードがテキストファイルとして静的に出力される
    - **Evidence**: 「ビルド成果物には従来のJavaScript/CSSアセットに加え、RSCペイロードがテキストファイルとして出力される」と説明され、`funstack__/rsc/fun:rsc-payload/`以下に複数のテキストファイルが生成されると具体的に記載
    - **Caveat**: この仕組みにより静的ホスティングが可能になりますが、サーバー側での動的なRSC処理は行えません

## Code Snippets
- **Vite設定ファイル**: FUNSTACK StaticをViteプラグインとして導入し、`root`と`app`の2つのエントリーポイントを指定する基本設定
- **defer() API使用例**: サーバーコンポーネント内でページコンポーネントをdefer()でラップし、ルーティング時に遅延読み込みを実現する実装パターン

```typescript
// Vite設定ファイル
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import funstackStatic from '@funstack/static';

export default defineConfig({
  plugins: [
    funstackStatic({
      root: "./src/Root.tsx",
      app: "./src/App.tsx",
    }),
    react(),
  ],
});
```

```typescript
// defer() API使用例
import { defer } from '@funstack/static/server';

export default function App() {
  return (
    <Router
      homeContents={defer(<HomePage />)}
      aboutContents={defer(<AboutPage />)}
    />
  );
}
```

## Normalized Conditions
- **Use Cases**:
    - サーバー運用コストを削減したい静的なWebアプリケーション
    - React Server Componentsのパフォーマンス最適化を活用したいSPA
    - ビルド時処理（設定ファイル読み込み、JSONインポート等）をアプリケーションコード内で自然に記述したい場合
    - 静的ファイルサーバー（GitHub Pages、Netlify、Vercel等）にデプロイしたいReactアプリ
    - ルーティングは既存ライブラリ（React Router等）で十分な場合
- **Anti-Cases**:
    - Server Actionsなどサーバー側の動的処理が必要な場合
    - 組み込みルーター機能が必要な場合
    - 将来的にサーバー必須機能への移行が予想される場合（マイグレーション難）
    - サーバーサイドでのリアルタイムデータ取得が必要な場合
- **Decision Triggers**:
    - サーバー運用コストを削減したいと判断した場合
    - 静的ホスティングのみで運用可能なアプリケーション要件が確定した場合
    - React Server Componentsのパフォーマンス最適化を活用したいが、サーバー運用は避けたい場合
    - ビルド時処理の柔軟性と静的配信を両立させたい場合
