---
title: 『単体テストの考え方/使い方』が良すぎた
url: https://qiita.com/ikenohotori/items/e88aabbdfa8ddd94810a
captured_at: 2026-01-22
published_at: 2024-01-01
---

# 『単体テストの考え方/使い方』が良すぎた

## TL;DR & Key Conclusions
『単体テストの考え方/使い方』は、単体テストの目的からトップダウンで設計・実装手法を説き、実践的な価値を最大化するための指針を提供する書籍のレビュー記事。各章に「まとめ」があり復習しやすく、理論と実践のバランスに優れた内容となっている。

- **単体テストの目的**: プロジェクトの成長を止めないこと。変更時の退行検出のセーフティーネット
- **良いテストの4つの柱**: 退行に対する保護、リファクタリングへの耐性、迅速なフィードバック、保守のしやすさ
- **テスト対象の選択**: 実装の詳細ではなく観測可能な振る舞いをテストする（リファクタリング耐性向上）
- **コードの複雑性重視**: 複雑なコード・ドメインにおける重要性が高いコードを優先的にテストする
- **アーキテクチャ推奨**: クリーンアーキテクチャ・関数型アーキテクチャの採用で質の高いテストを実現
- **AAAパターン**: 準備（Arrange）、実行（Act）、確認（Assert）の3フェーズで記述
- **命名規則**: メソッド名ではなく振る舞いに注目した名前を付ける（例: 「2つの数値の合計を返す()」）
- **ロンドン学派vs古典学派**: 単体テストの「単位」と「隔離」の考え方に2つの学派が存在
- **偽陽性の回避**: テストが実装の詳細と結びつくと偽陽性が発生し、開発者がテストを軽視するようになる
- **3つのテスト手法**: 出力値ベース（最良）、状態ベース、コミュニケーションベース
- **出力値ベーステストの推奨**: 実装の詳細と結びつきづらく、最も質の高いテストを作成できる
- **関数型アーキテクチャとの親和性**: 出力値ベーステストを書きやすくするために関数型アーキテクチャを採用

## Quickstart
この記事は概念的なレビュー記事であり、具体的な実装手順は含まれません。書籍『単体テストの考え方/使い方』の理解を深めるための以下の読み方を推奨：

1. **第1章を読む**: 単体テストの目的（プロジェクトの成長維持）を理解する
2. **第4章で基準を学ぶ**: 良いテストの4つの柱（保護、耐性、フィードバック、保守性）を把握
3. **第5章で対象を絞る**: 観測可能な振る舞いをテスト対象とする理由を理解
4. **第6章で実装戦略を選ぶ**: 出力値ベーステストと関数型アーキテクチャの関係を学ぶ
5. **各章の「まとめ」で復習**: 章ごとの要点を振り返り定着させる

## Context & Claims (Claim-Evidence-Caveat)

- **Claim**: 単体テストの目的は「プロジェクトの成長を持続可能にすること」である
    - **Evidence**: コードに変更を加えたときにテストがセーフティーネットとなり、退行を検出できる
    - **Caveat**: 適切に設計されたテストでない限り、労力に見合った結果が得られない

- **Claim**: 良い単体テストは4つの性質を持つ必要がある
    - **Evidence**: 退行に対する保護、リファクタリングへの耐性、迅速なフィードバック、保守のしやすさ。これらが揃わないとプロジェクト成長が阻害される
    - **Caveat**: 4つすべてを同時に最大化することは難しく、トレードオフを考慮する必要がある

- **Claim**: テストケースが偽陽性を生み出す最大の原因は、実装の詳細と結びついてしまうこと
    - **Evidence**: リファクタリング後にテストが失敗し続けると、開発者がテスト結果を重要視しなくなる
    - **Caveat**: 観測可能な振る舞いのみをテスト対象とすることで回避できるが、設計の見直しが必要な場合がある

- **Claim**: 単体テストには「ロンドン学派」と「古典学派」という2つの考え方が存在する
    - **Evidence**: ロンドン学派は「単位=クラス」「隔離=不変依存以外を全てモック化」、古典学派は「単位=テストケース」「隔離=共有依存のみモック化」
    - **Caveat**: どちらが優れているかは文脈依存。プロジェクトの性質によって選択するべき

- **Claim**: AAAパターン（準備・実行・確認）は単体テストの標準構造である
    - **Evidence**: 準備フェーズが最も大きく、実行フェーズは1行、確認フェーズはテスト対象次第という明確な指針がある
    - **Caveat**: すべてのテストケースがこのパターンに適合するわけではない

- **Claim**: テストの命名は振る舞いに注目すべきで、メソッド名に依存してはならない
    - **Evidence**: 「Sum_TwoNumbers_ReturnSum()」(悪い例)ではなく「2つの数値の合計を返す()」(良い例)のように、実装の詳細を隠す
    - **Caveat**: 日本語メソッド名を許容しないプログラミング言語では英語で表現する必要がある

- **Claim**: 正常系は1パターン、異常系は全パターンを1ケースに記載することで読みやすくなる
    - **Evidence**: `[InlineData]`などを用いて異常系のテストデータを集約することで、テストの意図が明確になる
    - **Caveat**: テストフレームワークによっては記法が異なる

- **Claim**: 出力値ベーステストが最も質の高いテストを作成できる
    - **Evidence**: 実装の詳細と結びつきづらく、偽陽性が発生しにくい
    - **Caveat**: すべての振る舞いが出力値で表現できるわけではなく、状態やコミュニケーションのテストも必要な場合がある

- **Claim**: 関数型アーキテクチャを採用することで出力値ベーステストを書きやすくなる
    - **Evidence**: 副作用を排除し、入出力のみに着目した設計により、テスト可能性が向上する
    - **Caveat**: 既存のオブジェクト指向コードベースをリファクタリングするコストが高い場合がある

- **Claim**: コードは負債であり、コードベースが大きくなると多くの潜在的バグを抱える
    - **Evidence**: 最終的にプロジェクトの成長を維持できなくなるため、退行検出が重要になる
    - **Caveat**: 適切なテスト戦略がなければ、テストコード自体が負債となる可能性がある

## Code Snippets
記事には実際のコードスニペットが含まれます：

- **AAAパターンのテスト例**: C#の`[Fact]`および`[Theory]`属性を用いた正常系・異常系テストの記述方法
- **テスト命名の良い例と悪い例**: `Sum_TwoNumbers_ReturnSum()`（悪）と「2つの数値の合計を返す()」（良）の比較
- **異常系テストのパラメータ化**: `[InlineData(-1)]`, `[InlineData(0)]`, `[InlineData(1)]`を用いた異常データの集約

## Normalized Conditions

- **Use Cases**:
    - 単体テストの設計・実装方針を学びたい開発者
    - テストコードのメンテナンスコストが高く悩んでいるチーム
    - リファクタリング時にテストが頻繁に壊れる（偽陽性が多い）プロジェクト
    - 「なぜテストを書くのか」をチームで共有したい場合
    - 技術書のレビューや推薦図書を探している開発者

- **Anti-Cases**:
    - 今すぐ使える具体的なテストコードが必要な場合（書籍レビューのため詳細な実装例は少ない）
    - 特定のテストフレームワークやプログラミング言語のみに特化した知識が必要な場合
    - 単体テスト以外のテスト手法（統合テスト、E2Eテストなど）を学びたい場合

- **Prerequisites**:
    - 何らかのプログラミング言語での開発経験
    - 単体テストの基本的な概念（テストケース、アサーション、モックなど）への理解
    - テストコードを書いた経験があるとより理解が深まる

- **Decision Triggers**:
    - テストコードの保守に時間がかかりすぎている
    - リファクタリングのたびにテストが失敗する
    - テストカバレッジは高いが品質が向上している実感がない
    - チーム内でテストの方針が統一されていない
    - 「良いテスト」の基準を明確にしたい
