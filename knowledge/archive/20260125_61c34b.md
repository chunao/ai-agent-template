---
title: "[翻訳] Anthropic ハッカソン優勝者による Claude Code 完全ガイド【応用編】"
url: https://zenn.dev/studypocket/articles/claude-code-complete-guide-advanced
captured_at: 2026-01-25
published_at: 2026-01-22
---

# [翻訳] Anthropic ハッカソン優勝者による Claude Code 完全ガイド【応用編】

## TL;DR & Key Conclusions

Claude Codeの応用技法を7つの戦略にまとめた実践ガイド。基礎編に続き、トークン最適化、並列化、継続的学習、評価ループといった高度なパターンを解説。Anthropicハッカソン優勝者による実戦知見。

- **コンテキスト管理**: 動的システムプロンプト注入とPreCompactフックで状態を永続化し、セッション間でメモリを共有
- **継続的学習**: Stopフックを使ってセッション終了時に有用パターンをスキル化し、再調整プロンプトのトークン浪費を削減
- **トークン最適化**: サブエージェントでHaikuに委任、pass@k評価で70-97%の精度を維持しながらコスト削減
- **検証ループ**: チェックポイントベースと継続的評価の2パターンで品質を担保、失敗時は修正必須
- **並列化戦略**: Git Worktreesで3-4タスク並行、カスケードメソッドで左から右へスイープ
- **基盤作り**: 2インスタンスキックオフ（スキャフォールディング+ディープリサーチ）で土台構築
- **サブエージェント設計**: シーケンシャルフェーズパターンと反復的取得で目的コンテキスト不足を解消
- **llms.txt活用**: `/llms.txt`経由でLLM最適化版ドキュメントを取得し、初期リサーチを効率化
- **モデル選択**: Sonnet（90%デフォルト）、Haiku（検索等）、Opus（5+ファイル・深い推論）で使い分け
- **評価指標**: pass@k（k=1: 70%, k=3: 91%, k=5: 97%）で複数試行の成功率を測定
- **エージェント抽象化**: Tier1（サブエージェント、メタプロンプティング）から始め、Tier2（長時間実行、並列）は段階的に
- **実践の前提**: 基礎編（ショートハンド）完了、スキル・エージェント・フック・MCP事前設定が必須

## Quickstart

1. **コンテキスト永続化の設定**: PreCompactフックとSessionStartフックを設定し、セッション間でメモリを引き継ぐ
   ```bash
   # 動的システムプロンプト注入
   claude --system-prompt "$(cat memory.md)"
   ```

2. **継続的学習の有効化**: Stopフックを設定し、セッション終了時に学習内容をスキル化
   - セッションログパターン: `~/.claude/sessions/YYYY-MM-DD-topic.tmp`
   - 手動抽出: `/learn`コマンド

3. **Git Worktreesで並列化**: 各フィーチャーごとに独立した作業ディレクトリを作成
   ```bash
   git worktree add /project-feature-a feature-a
   git worktree add /project-feature-b feature-b
   cd /project-feature-a
   claude
   ```

4. **2インスタンスキックオフ**: 新プロジェクト開始時に2つのインスタンスを同時起動
   - インスタンス1: スキャフォールディング（構造・設定・規約確立）
   - インスタンス2: ディープリサーチ（Web検索、アーキテクチャ図、llms.txt取得）

5. **サブエージェントでトークン最適化**: 検索タスクをHaikuモデルのサブエージェントに委任
   ```yaml
   name: quick search
   tools:
     - Glob
     - Grep
   model: haiku
   ```

## Context & Claims (Claim-Evidence-Caveat)

- **Claim**: 動的システムプロンプト注入はファイル参照より優先度が高い
  - **Evidence**: 命令階層構造の設計特性により、CLIフラグで渡されたシステムプロンプトがファイルベースの指示を上書きする
  - **Caveat**: セッション毎に異なるコンテキストを注入する必要があるため、自動化が困難

- **Claim**: Stopフックを使用し、UserPromptSubmitフックは使わない
  - **Evidence**: UserPromptSubmitは全メッセージで実行されるため、オーバーヘッドが大きい。Stopフックはセッション終了時のみトリガーされる
  - **Caveat**: セッション終了時にしか実行されないため、途中での学習内容保存には不向き

- **Claim**: 3-4タスク並行がベストプラクティス
  - **Evidence**: メンタルオーバーヘッド vs 生産性のトレードオフ分析により、それ以上の並行タスクは効率を低下させる
  - **Caveat**: 個人の能力やタスクの複雑度により最適値は変動する

- **Claim**: pass@k評価でk=1: 70%, k=3: 91%, k=5: 97%の精度
  - **Evidence**: k回試行のうち少なくとも1回成功する確率を測定した結果
  - **Caveat**: タスクの種類や難易度により数値は変動する。100%合格率はテスト不足の指標

- **Claim**: Git Worktreesで並列作業時のコンフリクトを回避
  - **Evidence**: 各フィーチャーが独立した作業ディレクトリを持つため、git競合が発生しない
  - **Caveat**: ディスク容量の消費が増加する。Worktree間での変更の同期は手動で行う必要がある

- **Claim**: llms.txtパターンでLLM最適化版ドキュメントを取得
  - **Evidence**: 多くのドキュメントサイトが`/llms.txt`経由でLLM向けに最適化されたコンテンツを提供している（例: `https://www.helius.dev/docs/llms.txt`）
  - **Caveat**: すべてのサイトが対応しているわけではない。対応状況は事前確認が必要

- **Claim**: サブエージェントでコンテキスト不足問題が発生
  - **Evidence**: 目的コンテキストが不足すると、サブエージェントが関連情報を抽出できない
  - **Caveat**: 反復的取得パターン（最大3サイクル）で解消可能だが、トークン消費が増加

- **Claim**: シーケンシャルフェーズパターンで段階的実装
  - **Evidence**: RESEARCH → PLAN → IMPLEMENT → REVIEW → VERIFY の5フェーズで各段階の成果物を明確化
  - **Caveat**: フェーズ間の依存関係が強く、前フェーズの失敗が後続に影響する

- **Claim**: モデル選択基準（Sonnet 90%, Haiku検索, Opus深い推論）
  - **Evidence**: タスクの複雑度とコスト効率のバランスから、90%のコーディングタスクはSonnetで対応可能
  - **Caveat**: 5ファイル以上やアーキテクチャレベルの深い推論が必要な場合はOpusが必要

- **Claim**: 評価100%合格率はテスト不足の指標
  - **Evidence**: 完璧な合格率は、テストが十分に厳しくない、またはエッジケースを捕捉していないことを示す
  - **Caveat**: 非常に単純なタスクや成熟したコードベースでは100%が妥当な場合もある

- **Claim**: 2インスタンスキックオフで土台構築を並列化
  - **Evidence**: スキャフォールディング（構造・設定・規約）とディープリサーチ（Web検索・アーキテクチャ図）を並行実行することで初期フェーズを加速
  - **Caveat**: 2つのインスタンスの成果物を統合する手間が発生する。初心者は単一インスタンスで十分

- **Claim**: 再利用可能パターンへの投資が長期的効率を向上
  - **Evidence**: サブエージェント、スキル/コマンド、MCPツール、コンテキストエンジニアリングパターンを一度作成すれば複数プロジェクトで再利用可能
  - **Caveat**: 初期投資コストが高く、小規模プロジェクトでは投資対効果が低い

## Code Snippets

- **動的システムプロンプト注入**: セッション毎に異なるコンテキストを動的にCLIフラグで注入
  ```bash
  claude --system-prompt "$(cat memory.md)"
  ```

- **Git Worktrees設定**: 各フィーチャーごとに独立した作業ディレクトリを作成
  ```bash
  git worktree add /project-feature-a feature-a
  git worktree add /project-feature-b feature-b
  cd /project-feature-a
  claude
  ```

- **サブエージェント定義（Haiku使用）**: 検索タスクを安価なHaikuモデルに委任
  ```yaml
  name: quick search
  tools:
    - Glob
    - Grep
  model: haiku
  ```

- **llms.txt取得例**: LLM最適化版ドキュメントをHTTP経由で取得
  ```
  https://www.helius.dev/docs/llms.txt
  ```

## Normalized Conditions

- **Use Cases**:
  - 大規模プロジェクトでトークン最適化が必要な場合
  - 複数タスクを並列実行してスループットを向上させたい場合
  - セッション間でコンテキストを保持し、再調整プロンプトを削減したい場合
  - 継続的な学習でClaudeの挙動を改善したい場合
  - 評価ループで品質を担保しながら開発を進めたい場合
  - 新規プロジェクトで土台構築を並列化したい場合
  - LLM最適化版ドキュメントが利用可能なサービスを使用している場合

- **Anti-Cases**:
  - 基礎編（ショートハンド）を理解していない場合
  - 小規模プロジェクトや単発タスクで再利用可能パターンの投資対効果が低い場合
  - 初心者がいきなり複数インスタンスや高度なエージェント抽象化を試みる場合
  - スキル、エージェント、フック、MCPの事前設定が未完了の場合
  - ディスク容量が限られている環境でGit Worktreesを多用する場合

- **Decision Triggers**:
  - トークン消費が予算を圧迫し始めた時
  - 3つ以上のタスクを同時進行する必要がある時
  - セッション間で同じコンテキストを何度も再入力している時
  - Claude Codeの挙動を改善するパターンを発見した時
  - 新規プロジェクトの初期フェーズで効率化を図りたい時
  - 5ファイル以上に跨るアーキテクチャレベルの深い推論が必要になった時
  - pass@k評価でk=1の成功率が70%を下回った時
